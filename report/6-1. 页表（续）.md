# 页表（续）

bbl 中创建的页表其实并不完善，几乎没有设置页面的读写等权限。所以本章我们将重新映射页表（remap kernel）。

首先我们需要获取需要重新映射内存的物理地址范围：
``` rust
// in memory/mod.rs

extern "C" {
    // text
    fn stext();
    fn etext();
    // data
    fn sdata();
    fn edata();
    // read only
    fn srodata();
    fn erodata();
    // bss
    fn sbss();
    fn ebss();
    // kernel
    fn start();
    fn end();
    // boot
    fn bootstack();
    fn bootstacktop();
}
```

这些函数赋值由 **boot/linker.ld** 完成，这里将他们作为 **usize** 使用。

``` rust
fn remap_kernel(dtb: usize) {
    let offset = - ( KERNEL_OFFSET as isize - MEMORY_OFFSET as isize);
    use crate::memory_set::{ MemorySet, handler::Linear, attr::MemoryAttr };
    let mut memset = MemorySet::new();
    memset.push(
        stext as usize,
        etext as usize,
        MemoryAttr::new().set_execute().set_readonly(),
        Linear::new(offset),
    );
    memset.push(
        srodata as usize,
        erodata as usize,
        MemoryAttr::new().set_readonly(),
        Linear::new(offset),
    );
    memset.push(
        sdata as usize,
        edata as usize,
        MemoryAttr::new(),
        Linear::new(offset),
    );
    memset.push(
        bootstack as usize,
        bootstacktop as usize,
        MemoryAttr::new(),
        Linear::new(offset),
    );
    memset.push(
        sbss as usize,
        ebss as usize,
        MemoryAttr::new(),
        Linear::new(offset),
    );
    memset.push(
        dtb as usize,
        dtb as usize + MAX_DTB_SIZE,
        MemoryAttr::new(),
        Linear::new(offset),
    );
    unsafe{
        memset.activate();
    }
}
```

``` markdown



PPN 表示 physical page number 。pte 的大小也为 32 位，与虚拟地址位数相同。不同的是，他存放了 22 位的物理地址（PPN）和 10 位的各类页面状态。



现在我们来演示如何通过二级页表将虚拟地址 `0xffeeffee` 转换为物理地址：

1. 通过 satp 获取二级页表的基址(satp.PPN)，VPN[1]给出了二级页号，因此处理器会读取位于地址（satp.PPN * PAGE_SIZE + VPN[1] * PTE_SIZE）的页表项。

2. 该 pte 包含一级页表的物理地址，VPN[0]给出了一级页号，因此处理器读取位于地址（pte.PPN * PAGE_SIZE + VPN[0] * PTE_SIZE）的叶节点页表项(leaf_pte)。

3. 叶节点页表项的 PPN 字段和页内偏移（原始虚拟地址的低 12 位）组成了最终的物理地址：leaf_pte.PPN * PAGE_SIZE + page_offset 。

> 在 riscv32 中，PAGE_SIZE = 4096，PTE_SIZE = 4

该过程可由下图表示：

![VA2PA_riscv32](img/VA2PA_riscv32.png)

> 这个转换过程并不严谨，后续我们将对其进行补充
## 一级页表

页表可以分级，有一级页表和多级页表。我们先来看最简单的一级页表的地址转换规范：

如图，在 riscv32 中，虚拟内存被分为两个部分：VPN 和 page offset ：



前 20 位用于寻找虚拟地址指向的物理内存所属的区域的起始地址，后 12 位是从起始地址开始的偏移量。

首先，在全局只有一个 **根页表** ，这里的 **根页表** 就是这个一级页表。我们随便选一个虚拟地址作为计算示例：`0xffeeffee` 。

首先将这个地址转为二进制，并且分为前 20 位和后 12 位：`b11111111111011101111_111111101110`
> 用 16 进制表示就是 `0xffeef_fee` 。

我们需要通过前 20 位找到 **页表项** 。 **页表项** 保存了虚拟地址指向的物理内存所属的区域的起始地址和属性（可读、可写、可执行等）。


然后通过后 12 位找到这个 **物理地址** 在页面中的具体位置。因为，后 12 位也有一个形象的名字：页内偏移（offset）。

前面我们讲过，页表可以理解为数组。假想这个数组（pg_table）的每一项大小都为 4kb ，那么我们需要找的页面就为： `pg_table[0xffeef]` 。

访问的物理地址为：
``` C++
typedef unsigned int uintptr_t;
uintptr_t(&pg_table[0xffeef]) + 0xfee;
```


虽然大家都叫他页表，但是这里叫 **页目录** 似乎更加贴切。（不过因为需要从众我也叫他页表吧
> 请牢记 **页目录** 这个词，这有利于后续对页表的理解

**页表可以理解为数组，数组的每一项都是一个页面（或者下一级页表）的地址。**
在 riscv32 架构中，每个页面的大小为 4kb 。

VPN 表示 virtual page number 。由于我们采用了多级页表，所以需要引入 **页表项（page table entry）** ，简称 pte 。其结构如下：
> 直译为页目录入口似乎更加形象
```

## 预告

本章我们实现了分页机制，并且对物理地址和虚拟地址有了一定的了解。下一章我们将探测可分配物理内存，并实现物理内存的分配和释放。