# 页表（续）

bbl 中创建的页表其实并不完善，几乎没有设置页面的读写等权限。所以本章我们将重新映射页表（remap kernel）。

首先我们需要获取需要重新映射内存的物理地址范围：
``` rust
// in memory/mod.rs

extern "C" {
    // text
    fn stext();
    fn etext();
    // data
    fn sdata();
    fn edata();
    // read only
    fn srodata();
    fn erodata();
    // bss
    fn sbss();
    fn ebss();
    // kernel
    fn start();
    fn end();
    // boot
    fn bootstack();
    fn bootstacktop();
}
```

这些函数赋值由 **boot/linker.ld** 完成，这里将他们作为 **usize** 使用。

``` rust
fn remap_kernel(dtb: usize) {
    let offset = - ( KERNEL_OFFSET as isize - MEMORY_OFFSET as isize);
    use crate::memory_set::{ MemorySet, handler::Linear, attr::MemoryAttr };
    let mut memset = MemorySet::new();
    memset.push(
        stext as usize,
        etext as usize,
        MemoryAttr::new().set_execute().set_readonly(),
        Linear::new(offset),
    );
    memset.push(
        srodata as usize,
        erodata as usize,
        MemoryAttr::new().set_readonly(),
        Linear::new(offset),
    );
    memset.push(
        sdata as usize,
        edata as usize,
        MemoryAttr::new(),
        Linear::new(offset),
    );
    memset.push(
        bootstack as usize,
        bootstacktop as usize,
        MemoryAttr::new(),
        Linear::new(offset),
    );
    memset.push(
        sbss as usize,
        ebss as usize,
        MemoryAttr::new(),
        Linear::new(offset),
    );
    memset.push(
        dtb as usize,
        dtb as usize + MAX_DTB_SIZE,
        MemoryAttr::new(),
        Linear::new(offset),
    );
    unsafe{
        memset.activate();
    }
}
```